{"meta":{"title":"GaoYida","subtitle":null,"description":"Something Just Like This!","author":"GaoYida","url":"https://gaoyida.github.io"},"pages":[],"posts":[{"title":"Mybatis之Possible unexpected auto-mapping","slug":"Mybatis之Possible unexpected auto-mapping","date":"2018-12-17T11:44:27.000Z","updated":"2019-11-17T11:02:10.000Z","comments":true,"path":"2018/12/17/Mybatis之Possible unexpected auto-mapping/","link":"","permalink":"https://gaoyida.github.io/2018/12/17/Mybatis之Possible unexpected auto-mapping/","excerpt":"","text":"&emsp;&emsp;最近在做项目改造，将项目改造成SpringBoot应用。主要工作规整旧的配置，调整部分代码结构，对项目的代码未做变动，完成后提交给QA做回归验证。&emsp;&emsp;就在上周，测试同学将我唤了过去，说有页面请求接口报500。看到现象顿感疑惑，首先我并未修改之前的代码，查看线上master分支是运行正常的，是否是测试环境有脏数据？或者登陆异常？&emsp;&emsp;查看测试环境的日志，代码有一处抛了空指针，为了简化描述，还原当时的代码场景如下：1234105 for (Account account : accounts) &#123;106 User user = userService.findById(account.getUserId());107 String userId = user.getName() + \"(\" + account.getUserId() + \")\";108 &#125; &emsp;&emsp;日志分析空指针是在第107行的 user.getName() 抛出的。一眼看去，的确未对user是否为空作判断，遂执行查询数据库的SQL，看是否有account和user数据不一致的情况，结果user均可查到！让我们看下AccountMapper.xml里的查询：1234567891011&lt;resultMap id=\"BaseResultMap\" type=\"com.xxx.User\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\" /&gt;&lt;/resultMap&gt;&lt;select id=\"getAccountDetail\" resultMap=\"BaseResultMap\"&gt; SELECT id, user_id as userId from account&lt;/select&gt; &emsp;&emsp;这样看，userId拿出来肯定是空的呀，我们使用的对象里属性是userId，为什么线上master分支还能正确执行？（当时怀疑合代码的问题，后查看master分支代码是一致的）。&emsp;&emsp;为什么相同的代码跑出了不同的结果，还和我预想的结果刚好相反。（猜想是master运行应该也会报错才对）。不对，还是可能存在不同的代码，就是我引入的jar包。在原来的Web工程里，引入的mybais是：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;dependency&gt; 当前springboot应用引入的依赖里，使用的mybatis是3.4.5。12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;dependency&gt; &emsp;&emsp;难道是这两个版本之间的改动？可能别人也遇到过这样的问题。于是到GitHub的mybatis项目上看3.4.3到3.4.5的发布日志，发现了蛛丝马迹：&emsp;&emsp;我们由此知道在3.4.2出现的现象是个bug，3.4.3版本修复了这个问题。问题已经找到。解决办法呢？是修改原有代码还是将错就错？由于原版本一直良好运行，以及提升版本也可能出现其他的问题，于是选择继续沿用3.4.2版本。&emsp;&emsp;坑就如同上述，但是导致这一问题的原因是什么，PR #895 是如何修复这个bug的呢？&emsp;&emsp;我们需要对源码作进一步分析。对这个bug的修复主要涉及两个文件——DefaultResultSetHandler.java和ResultMap.java。DefaultResultSetHandler处理SQL查询结果集，生成结果列表。通过debug看到结果映射调用堆栈是（代码版本mybatis 3.4.2）： loadMappedAndUnmappedColumnNames getUnmappedColumnNames createAutomaticMappings applyAutomaticMappings getRowValue handleRowValuesForSimpleResultMap handleRowValues 查看代码片段1，select 出的 userId 因为没有在resultMap里找到column映射，所以被放在unmappedColumnNames里返回。查看代码片段2，尝试将unmappedColumnNames放入automapping。查看代码片段3，得到userId的value.查看代码片段4，代码里先automapping，再使用propertymapping，所以查出的结果userId值获取到了。&emsp;&emsp;当前的判断逻辑是在unmappedColumnNames中的属性，如果对象里有该属性且有set方法会被自动映射(mybatis自动映射是默认打开的)。实际应该在resultmap里未被映射的情况下才使用自动映射，即存在映射如下，默认的userId -&gt; userId不应该生效。1&lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\" /&gt; &emsp;&emsp;所以在修复的版本(mybatis 3.4.3)中在增加resultmap的property记录，并且增加if判断条件。即unmappedColumnNames中的userId在判断时包含在mappedProperties里，不会被自动映射，会遵从xml里的resultmap。&emsp;&emsp;至此问题得到解决，本文主要围绕问题#895 分析，感谢阅读。","categories":[],"tags":[]},{"title":"一些记录","slug":"第一篇","date":"2018-02-17T08:31:07.000Z","updated":"2019-11-17T10:41:50.000Z","comments":true,"path":"2018/02/17/第一篇/","link":"","permalink":"https://gaoyida.github.io/2018/02/17/第一篇/","excerpt":"","text":"Don’t let others noise drown out your own inner voice, and most importantly, have the courage to follow your heart and intuition. 对一个优秀工程师最大的致敬就是学习并超过他。","categories":[],"tags":[]}]}