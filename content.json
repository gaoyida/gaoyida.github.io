{"meta":{"title":"GaoYida","subtitle":null,"description":"Something Just Like This!","author":"GaoYida","url":"https://gaoyida.github.io"},"pages":[{"title":"博客分类","date":"2019-11-17T12:23:09.000Z","updated":"2019-11-17T12:25:29.000Z","comments":true,"path":"categories/index.html","permalink":"https://gaoyida.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-17T12:22:18.000Z","updated":"2019-11-17T12:29:01.000Z","comments":true,"path":"tags/index.html","permalink":"https://gaoyida.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"分布式发号器-Fly","slug":"分布式发号器-Fly","date":"2019-11-15T11:10:11.000Z","updated":"2019-11-18T02:08:43.000Z","comments":true,"path":"2019/11/15/分布式发号器-Fly/","link":"","permalink":"https://gaoyida.github.io/2019/11/15/分布式发号器-Fly/","excerpt":"","text":"引言&emsp;&emsp;前不久看到一篇文章，如何做一个靠谱的发号器，觉得是个挺好的设计，于是使用Java实现了一番。 Fly&emsp;&emsp;发号器，取名fly的意思是，像有无数飞虫一样，不断产生，取之不尽。查看项目地址。 持久化&emsp;&emsp;UID的生成记录会写入ZooKeeper，服务初始化/重启时从ZooKeeper读取配置信息。使用初始化作为持久化的原因是，ZooKeeper是强一致的，在全局单调ID的生成模式下，如果主服务器宕机，可以切换备服务器工作，备服务器从ZooKeeper读取配置，保证发出的ID是唯一的。&emsp;&emsp;如果采用MySQL和Redis产生ID的实现，由于MySQL和Redis的复制机制无法保证强一致，当MySQL或Redis发生主备切换，备机尚未完全同步的话，还是会发出重复的ID。 通信协议&emsp;&emsp;实现TLV格式的协议。 高可用方案设计&emsp;&emsp;对于全局单调ID的生成，需要使用主备模式；对于全局唯一ID的生成，主备模式和负载均衡模式均可实现。在实际使用时，我们倾向于全局单调ID使用主备模式，全局唯一ID使用负载均衡模式部署服务。 主备模式架构图 选主&emsp;&emsp;部署服务的实例会在zk进行master节点抢占，抢占成功的实例会成为master，执行id的生成和分配。其他服务器会成为备服务器，执行客户端请求的转发，保障高可用。 ID的生成规则&emsp;&emsp;全局单调性，目前实现是一个不断递增的整数。 主备切换&emsp;&emsp;当前运行的服务端会写到zk里，如果异常/下线将触发事件通知其他运行实例进行抢占执行。注意，因为服务端实现了转发，对客户端来说是无感知的，当客户端连接原master异常时，会自动尝试连接其他服务地址。 缺点&emsp;&emsp;服务非负载均衡。 负载均衡模式架构图 部署&emsp;&emsp;所有服务实例都是平等的对外提供服务。没有主从之分。 ID的生成规则&emsp;&emsp;基于Twitter的SnowFlake算法，具体规则：参考 服务宕机&emsp;&emsp;客户端自动尝试连接其他服务地址。 缺点&emsp;&emsp;UUID的取用非全局单调。 主要代码FlyService&emsp;&emsp;接收处理客户端请求，默认端口是8888。对于当前非master的服务实例，将执行转发请求到master服务实例。 ForwardService&emsp;&emsp;提供转发服务。具体实现是维护到master的连接池，同时当有请求发出的时候，将异步结果获取转为同步。 StateMachine&emsp;&emsp;维护当前服务实例的状态，是否是master，是否avaliable等。当有master状态转变时，需要实时更新资源。 FlyManager&emsp;&emsp;负责与zk的交互，执行master抢占和监听。 TODO 考虑到如果zk服务出现异常，我们可以降级到通过数据库实现UUID生成。 转发协议，压测转发处理的性能，以及连接池的优化；客户端连接管理。 完成客户端实现。","categories":[{"name":"分布式应用","slug":"分布式应用","permalink":"https://gaoyida.github.io/categories/分布式应用/"}],"tags":[]},{"title":"Mybatis之Possible unexpected auto-mapping","slug":"Mybatis之Possible unexpected auto-mapping","date":"2018-12-17T11:44:27.000Z","updated":"2019-11-17T12:30:42.000Z","comments":true,"path":"2018/12/17/Mybatis之Possible unexpected auto-mapping/","link":"","permalink":"https://gaoyida.github.io/2018/12/17/Mybatis之Possible unexpected auto-mapping/","excerpt":"","text":"&emsp;&emsp;最近在做项目改造，将项目改造成SpringBoot应用。主要工作规整旧的配置，调整部分代码结构，对项目的代码未做变动，完成后提交给QA做回归验证。&emsp;&emsp;就在上周，测试同学将我唤了过去，说有页面请求接口报500。看到现象顿感疑惑，首先我并未修改之前的代码，查看线上master分支是运行正常的，是否是测试环境有脏数据？或者登陆异常？&emsp;&emsp;查看测试环境的日志，代码有一处抛了空指针，为了简化描述，还原当时的代码场景如下：1234105 for (Account account : accounts) &#123;106 User user = userService.findById(account.getUserId());107 String userId = user.getName() + \"(\" + account.getUserId() + \")\";108 &#125; &emsp;&emsp;日志分析空指针是在第107行的 user.getName() 抛出的。一眼看去，的确未对user是否为空作判断，遂执行查询数据库的SQL，看是否有account和user数据不一致的情况，结果user均可查到！让我们看下AccountMapper.xml里的查询：1234567891011&lt;resultMap id=\"BaseResultMap\" type=\"com.xxx.User\"&gt; &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\" /&gt; &lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\" /&gt;&lt;/resultMap&gt;&lt;select id=\"getAccountDetail\" resultMap=\"BaseResultMap\"&gt; SELECT id, user_id as userId from account&lt;/select&gt; &emsp;&emsp;这样看，userId拿出来肯定是空的呀，我们使用的对象里属性是userId，为什么线上master分支还能正确执行？（当时怀疑合代码的问题，后查看master分支代码是一致的）。&emsp;&emsp;为什么相同的代码跑出了不同的结果，还和我预想的结果刚好相反。（猜想是master运行应该也会报错才对）。不对，还是可能存在不同的代码，就是我引入的jar包。在原来的Web工程里，引入的mybais是：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;dependency&gt; 当前springboot应用引入的依赖里，使用的mybatis是3.4.5。12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;dependency&gt; &emsp;&emsp;难道是这两个版本之间的改动？可能别人也遇到过这样的问题。于是到GitHub的mybatis项目上看3.4.3到3.4.5的发布日志，发现了蛛丝马迹：&emsp;&emsp;我们由此知道在3.4.2出现的现象是个bug，3.4.3版本修复了这个问题。问题已经找到。解决办法呢？是修改原有代码还是将错就错？由于原版本一直良好运行，以及提升版本也可能出现其他的问题，于是选择继续沿用3.4.2版本。&emsp;&emsp;坑就如同上述，但是导致这一问题的原因是什么，PR #895 是如何修复这个bug的呢？&emsp;&emsp;我们需要对源码作进一步分析。对这个bug的修复主要涉及两个文件——DefaultResultSetHandler.java和ResultMap.java。DefaultResultSetHandler处理SQL查询结果集，生成结果列表。通过debug看到结果映射调用堆栈是（代码版本mybatis 3.4.2）： loadMappedAndUnmappedColumnNames getUnmappedColumnNames createAutomaticMappings applyAutomaticMappings getRowValue handleRowValuesForSimpleResultMap handleRowValues 查看代码片段1，select 出的 userId 因为没有在resultMap里找到column映射，所以被放在unmappedColumnNames里返回。查看代码片段2，尝试将unmappedColumnNames放入automapping。查看代码片段3，得到userId的value.查看代码片段4，代码里先automapping，再使用propertymapping，所以查出的结果userId值获取到了。&emsp;&emsp;当前的判断逻辑是在unmappedColumnNames中的属性，如果对象里有该属性且有set方法会被自动映射(mybatis自动映射是默认打开的)。实际应该在resultmap里未被映射的情况下才使用自动映射，即存在映射如下，默认的userId -&gt; userId不应该生效。1&lt;result column=\"user_id\" jdbcType=\"VARCHAR\" property=\"userId\" /&gt; &emsp;&emsp;所以在修复的版本(mybatis 3.4.3)中在增加resultmap的property记录，并且增加if判断条件。即unmappedColumnNames中的userId在判断时包含在mappedProperties里，不会被自动映射，会遵从xml里的resultmap。&emsp;&emsp;至此问题得到解决，本文主要围绕问题#895 分析，感谢阅读。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://gaoyida.github.io/categories/mybatis/"}],"tags":[]},{"title":"一些记录","slug":"第一篇","date":"2018-02-17T08:31:07.000Z","updated":"2019-11-17T10:41:50.000Z","comments":true,"path":"2018/02/17/第一篇/","link":"","permalink":"https://gaoyida.github.io/2018/02/17/第一篇/","excerpt":"","text":"Don’t let others noise drown out your own inner voice, and most importantly, have the courage to follow your heart and intuition. 对一个优秀工程师最大的致敬就是学习并超过他。","categories":[],"tags":[]}]}